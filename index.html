<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generador Dodecafónico</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/tone@14.7.58/build/Tone.js"></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        .note-display {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .note-item {
            background-color: #ffffff;
            padding: 0.5rem 0.75rem;
            border-radius: 9999px;
            border: 1px solid #e5e7eb;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            font-size: 1.125rem;
            color: #4b5563;
            transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        /* CSS class for highlighting the note that is being played */
        .note-highlight {
            background-color: #60a5fa;
            color: white;
            box-shadow: 0 0 10px #60a5fa;
        }
        .card {
            background-color: #ffffff;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            border: 1px solid #e5e7eb;
            margin-bottom: 2rem;
        }
        .series-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .play-button {
            padding: 0.5rem;
            border-radius: 9999px;
            background-color: #60a5fa;
            color: white;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .play-button:hover {
            background-color: #3b82f6;
            transform: scale(1.1);
        }
        .action-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 2rem;
        }
        .action-button {
            font-weight: 700;
            padding: 0.75rem 1.5rem;
            border-radius: 9999px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transition: transform 0.2s;
        }
        .action-button:hover {
            transform: scale(1.05);
        }
        .generate-button {
            background-color: #2563eb;
            color: white;
        }
        .save-button {
            background-color: #4b5563;
            color: white;
        }
        .grouped-series-container {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
        }
        .group-display {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .group-card {
            background-color: #ffffff;
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
            border: 1px solid #e5e7eb;
        }
        .matrix-container {
            overflow-x: auto;
            width: 100%;
        }
        #matrixTable {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.75rem;
        }
        #matrixTable th, #matrixTable td {
            text-align: center;
            padding: 0.25rem;
            border: 1px solid #e5e7eb;
            white-space: nowrap;
            cursor: pointer;
        }
        #matrixTable thead th, #matrixTable tbody th, #matrixTable tfoot th {
            background-color: #e5e7eb;
            font-weight: 700;
        }
        /* CSS class for highlighting a matrix cell */
        .matrix-cell-highlight {
            background-color: #a5b4fc;
            color: white;
            font-weight: bold;
        }
        /* CSS class for highlighting a matrix header */
        .matrix-header-highlight {
            background-color: #818cf8;
            color: white;
        }
        /* Styles for R and RI headers */
        #matrixTable .r-header, #matrixTable .ri-header {
            background-color: #e5e7eb;
        }
        #matrixTable .r-header:hover, #matrixTable .ri-header:hover {
            background-color: #d1d5db;
        }

        @media (min-width: 640px) {
            #matrixTable {
                font-size: 0.875rem;
            }
            #matrixTable th, #matrixTable td {
                padding: 0.5rem;
            }
        }
    </style>
</head>
<body class="flex flex-col min-h-screen">
    <div class="flex-grow p-4 overflow-y-auto">
        <div id="appCard" class="max-w-4xl w-full mx-auto">
            <h1 class="text-4xl font-extrabold text-center text-gray-900 mb-2 tracking-tight">
                Generador Dodecafónico
            </h1>
            <p class="text-center text-gray-600 mb-6 max-w-2xl mx-auto text-sm">
                Diseñado por Juan Miguel Rios Redondo
            </p>

            <!-- Action buttons container -->
            <div class="action-buttons">
                <button id="generateButton" class="action-button generate-button">
                    Generar Nueva Serie
                </button>
                <button id="saveButton" class="action-button save-button">
                    Guardar como Imagen
                </button>
            </div>

            <!-- Display section for the four basic series -->
            <div class="space-y-6 mb-8 card">
                <div class="bg-gray-100 p-4 rounded-lg shadow-inner">
                    <div class="series-header mb-2">
                        <h3 class="text-xl font-semibold text-gray-800">1. Prime (P)</h3>
                        <button class="play-button" data-series-type="prime" data-target-id="primeSeries">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5">
                                <path d="M6.3 2.841A1.5 1.5 0 004 4.11V15.89a1.5 1.5 0 002.3 1.269l9.077-6.13a1.5 1.5 0 000-2.538L6.3 2.84z" />
                            </svg>
                        </button>
                    </div>
                    <p class="text-sm text-gray-500 mb-4">Esta es la serie original, una secuencia única de los 12 tonos cromáticos. Sirve como base para todas las demás formas, garantizando que no contiene tríadas tonales.</p>
                    <ul id="primeSeries" class="note-display"></ul>
                </div>
                <div class="bg-gray-100 p-4 rounded-lg shadow-inner">
                    <div class="series-header mb-2">
                        <h3 class="text-xl font-semibold text-gray-800">2. Inversión (I)</h3>
                        <button class="play-button" data-series-type="inversion" data-target-id="inversionSeries">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5">
                                <path d="M6.3 2.841A1.5 1.5 0 004 4.11V15.89a1.5 1.5 0 002.3 1.269l9.077-6.13a1.5 1.5 0 000-2.538L6.3 2.84z" />
                            </svg>
                        </button>
                    </div>
                    <p class="text-sm text-gray-500 mb-4">Se invierten los intervalos de la serie original. Si un intervalo sube, la inversión lo hace bajar en la misma cantidad de semitonos, y viceversa.</p>
                    <ul id="inversionSeries" class="note-display"></ul>
                </div>
                <div class="bg-gray-100 p-4 rounded-lg shadow-inner">
                    <div class="series-header mb-2">
                        <h3 class="text-xl font-semibold text-gray-800">3. Retrógrada (R)</h3>
                        <button class="play-button" data-series-type="retrograde" data-target-id="retrogradeSeries">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5">
                                <path d="M6.3 2.841A1.5 1.5 0 004 4.11V15.89a1.5 1.5 0 002.3 1.269l9.077-6.13a1.5 1.5 0 000-2.538L6.3 2.84z" />
                            </svg>
                        </button>
                    </div>
                    <p class="text-sm text-gray-500 mb-4">Es la serie original leída al revés, comenzando por la última nota y terminando con la primera.</p>
                    <ul id="retrogradeSeries" class="note-display"></ul>
                </div>
                <div class="bg-gray-100 p-4 rounded-lg shadow-inner">
                    <div class="series-header mb-2">
                        <h3 class="text-xl font-semibold text-gray-800">4. Inversión Retrógrada (IR)</h3>
                        <button class="play-button" data-series-type="inversionRetrograde" data-target-id="inversionRetrogradeSeries">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5">
                                <path d="M6.3 2.841A1.5 1.5 0 004 4.11V15.89a1.5 1.5 0 002.3 1.269l9.077-6.13a1.5 1.5 0 000-2.538L6.3 2.84z" />
                            </svg>
                        </button>
                    </div>
                    <p class="text-sm text-gray-500 mb-4">Es la inversión de la serie, pero leída al revés.</p>
                    <ul id="inversionRetrogradeSeries" class="note-display"></ul>
                </div>
            </div>

            <!-- Section for grouping the series -->
            <div class="card mb-8">
                <div class="series-header mb-4">
                    <h3 class="text-xl font-semibold text-gray-800">Segmentación de la Serie Principal</h3>
                    <select id="groupSelect" class="rounded-full px-3 py-1 bg-white border border-gray-300 shadow-sm">
                        <option value="2">Grupos de 2</option>
                        <option value="3">Grupos de 3</option>
                        <option value="4">Grupos de 4</option>
                        <option value="6">Grupos de 6</option>
                    </select>
                </div>
                <div id="groupedSeriesContainer" class="grouped-series-container"></div>
            </div>
            
            <!-- Display section for the 12x12 matrix -->
            <div class="card mb-8">
                <div class="series-header mb-4">
                    <h3 class="text-xl font-semibold text-gray-800">Matriz Dodecafónica</h3>
                </div>
                <p class="text-sm text-gray-500 mb-4">
                    Esta tabla de 12x12 contiene las 48 formas posibles de la serie dodecafónica. Haz clic en cualquier celda o encabezado para ver las cuatro formas relacionadas (P, I, R, IR) en el panel de abajo.
                    <br><br>
                    Para leer la matriz:
                    <ul>
                        <li><b>P (Prime):</b> Lee las filas de izquierda a derecha. Los encabezados P están en el lado izquierdo de la matriz.</li>
                        <li><b>I (Inversión):</b> Lee las columnas de arriba abajo. Los encabezados I están en la parte superior de la matriz.</li>
                        <li><b>R (Retrógrada):</b> Lee las filas de derecha a izquierda.</li>
                        <li><b>Inversión Retrógrada (IR):</b> Lee las columnas de abajo a arriba. Los encabezados IR están en la parte inferior de la matriz.</li>
                    </ul>
                </p>
                <div class="matrix-container">
                    <table id="matrixTable"></table>
                </div>
            </div>

            <!-- New section for showing the four series from a matrix click -->
            <div id="matrixSeriesDisplay" class="card hidden">
                <h3 class="text-xl font-semibold text-gray-800 mb-4">Formas de la Serie Relacionadas</h3>
                
                <div id="selectedSeriesInfoP" class="mb-4 bg-gray-100 p-4 rounded-lg shadow-inner">
                    <div class="series-header mb-2">
                        <h4 class="text-lg font-bold text-gray-800" id="seriesTitleP">Prime (P):</h4>
                        <button class="play-button" data-series-type="P" data-target-id="selectedSeriesNotesP">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5">
                                <path d="M6.3 2.841A1.5 1.5 0 004 4.11V15.89a1.5 1.5 0 002.3 1.269l9.077-6.13a1.5 1.5 0 000-2.538L6.3 2.84z" />
                            </svg>
                        </button>
                    </div>
                    <ul id="selectedSeriesNotesP" class="note-display"></ul>
                </div>
                
                <div id="selectedSeriesInfoI" class="mb-4 bg-gray-100 p-4 rounded-lg shadow-inner">
                    <div class="series-header mb-2">
                        <h4 class="text-lg font-bold text-gray-800" id="seriesTitleI">Inversión (I):</h4>
                        <button class="play-button" data-series-type="I" data-target-id="selectedSeriesNotesI">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5">
                                <path d="M6.3 2.841A1.5 1.5 0 004 4.11V15.89a1.5 1.5 0 002.3 1.269l9.077-6.13a1.5 1.5 0 000-2.538L6.3 2.84z" />
                            </svg>
                        </button>
                    </div>
                    <ul id="selectedSeriesNotesI" class="note-display"></ul>
                </div>
                
                <div id="selectedSeriesInfoR" class="mb-4 bg-gray-100 p-4 rounded-lg shadow-inner">
                    <div class="series-header mb-2">
                        <h4 class="text-lg font-bold text-gray-800" id="seriesTitleR">Retrógrada (R):</h4>
                        <button class="play-button" data-series-type="R" data-target-id="selectedSeriesNotesR">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5">
                                <path d="M6.3 2.841A1.5 1.5 0 004 4.11V15.89a1.5 1.5 0 002.3 1.269l9.077-6.13a1.5 1.5 0 000-2.538L6.3 2.84z" />
                            </svg>
                        </button>
                    </div>
                    <ul id="selectedSeriesNotesR" class="note-display"></ul>
                </div>

                <div id="selectedSeriesInfoIR" class="mb-4 bg-gray-100 p-4 rounded-lg shadow-inner">
                    <div class="series-header mb-2">
                        <h4 class="text-lg font-bold text-gray-800" id="seriesTitleIR">Inversión Retrógrada (IR):</h4>
                        <button class="play-button" data-series-type="IR" data-target-id="selectedSeriesNotesIR">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5">
                                <path d="M6.3 2.841A1.5 1.5 0 004 4.11V15.89a1.5 1.5 0 002.3 1.269l9.077-6.13a1.5 1.5 0 000-2.538L6.3 2.84z" />
                            </svg>
                        </button>
                    </div>
                    <ul id="selectedSeriesNotesIR" class="note-display"></ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Define the note names of the chromatic scale.
            const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

            // Tone.js variables
            let synth;
            let sequence;
            let currentSeriesData;
            let currentMatrix;
            let selectedMatrixSeries = {};
            
            // Define triad intervals for a quick search.
            const allTriadIntervals = [
                [4, 3], [3, 4], [3, 5], [4, 5], [5, 4], [5, 3]
            ];
            
            // Function to check if the last three notes of a series form a triad.
            const checkForTriads = (series) => {
                if (series.length < 3) return false;
                const n1 = noteNames.indexOf(series[series.length - 3]);
                const n2 = noteNames.indexOf(series[series.length - 2]);
                const n3 = noteNames.indexOf(series[series.length - 1]);
                const interval1 = (n2 - n1 + 12) % 12;
                const interval2 = (n3 - n2 + 12) % 12;
                for (const triad of allTriadIntervals) {
                    if (interval1 === triad[0] && interval2 === triad[1]) return true;
                }
                return false;
            };

            // Function to generate a random 12-tone series without triads.
            const generateRandomSeries = () => {
                const availableNotes = [...noteNames];
                const series = [];
                const firstNoteIndex = Math.floor(Math.random() * availableNotes.length);
                series.push(availableNotes.splice(firstNoteIndex, 1)[0]);

                while (series.length < 12) {
                    if (availableNotes.length === 0) return generateRandomSeries();
                    const randomIndex = Math.floor(Math.random() * availableNotes.length);
                    const newNote = availableNotes[randomIndex];
                    const tentativeSeries = [...series, newNote];

                    if (!checkForTriads(tentativeSeries)) {
                        series.push(newNote);
                        availableNotes.splice(randomIndex, 1);
                    } else {
                        availableNotes.splice(randomIndex, 1);
                    }
                }
                return series;
            };

            // Function to get the inversion of the series.
            const getInversion = (prime) => {
                const inversion = [];
                inversion.push(prime[0]);
                for (let i = 1; i < prime.length; i++) {
                    const currentNoteIndex = noteNames.indexOf(prime[i]);
                    const prevNoteIndex = noteNames.indexOf(prime[i - 1]);
                    const interval = currentNoteIndex - prevNoteIndex;
                    const lastInversionNoteIndex = noteNames.indexOf(inversion[i - 1]);
                    let newNoteIndex = (lastInversionNoteIndex - interval + 12) % 12;
                    inversion.push(noteNames[newNoteIndex]);
                }
                return inversion;
            };

            // Function to get the retrograde series.
            const getRetrograde = (series) => [...series].reverse();

            // Function to get the inversion retrograde.
            const getInversionRetrograde = (series) => getInversion(series).reverse();

            // Function to render a series on the page.
            const renderSeries = (elementId, series) => {
                const ul = document.getElementById(elementId);
                if (!ul) return;
                ul.innerHTML = '';
                series.forEach(note => {
                    const li = document.createElement('li');
                    li.textContent = note;
                    li.className = 'note-item';
                    ul.appendChild(li);
                });
            };

            // Function to generate the dodecaphonic matrix.
            const generateMatrix = (prime) => {
                const matrix = [];
                const inversion = getInversion(prime);
                matrix.push(prime);
                for (let i = 1; i < 12; i++) {
                    const newRow = [];
                    const firstNoteOfRow = inversion[i];
                    newRow.push(firstNoteOfRow);
                    for (let j = 1; j < 12; j++) {
                        const originalInterval = (noteNames.indexOf(prime[j]) - noteNames.indexOf(prime[0]) + 12) % 12;
                        const newNoteIndex = (noteNames.indexOf(firstNoteOfRow) + originalInterval) % 12;
                        newRow.push(noteNames[newNoteIndex]);
                    }
                    matrix.push(newRow);
                }
                return matrix;
            };

            // Function to render the matrix on the page with click events (UPDATED)
            const renderMatrix = (matrix) => {
                const table = document.getElementById('matrixTable');
                if (!table) return;
                table.innerHTML = '';
                
                // Table header with I headers
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                headerRow.innerHTML = '<th></th>'; // Empty cell for the corner
                const inversionSeries = getInversion(currentSeriesData.prime);
                inversionSeries.forEach((note, index) => {
                    const th = document.createElement('th');
                    th.textContent = `I${index}`;
                    th.setAttribute('data-type', 'I');
                    th.setAttribute('data-index', index);
                    headerRow.appendChild(th);
                });
                headerRow.innerHTML += `<th class="r-header" data-type="R" data-index="0">R0</th>`; // R header for the first row
                thead.appendChild(headerRow);
                table.appendChild(thead);

                // Table body
                const tbody = document.createElement('tbody');
                matrix.forEach((row, rowIndex) => {
                    const tr = document.createElement('tr');
                    
                    const rowHeaderP = document.createElement('th');
                    rowHeaderP.textContent = `P${rowIndex}`;
                    rowHeaderP.setAttribute('data-type', 'P');
                    rowHeaderP.setAttribute('data-index', rowIndex);
                    tr.appendChild(rowHeaderP);
                    
                    row.forEach((note, colIndex) => {
                        const td = document.createElement('td');
                        td.textContent = note;
                        td.setAttribute('data-row', rowIndex);
                        td.setAttribute('data-col', colIndex);
                        tr.appendChild(td);
                    });
                    
                    const rowHeaderR = document.createElement('th');
                    rowHeaderR.textContent = `R${rowIndex}`;
                    rowHeaderR.setAttribute('data-type', 'R');
                    rowHeaderR.setAttribute('data-index', rowIndex);
                    tr.appendChild(rowHeaderR);
                    
                    tbody.appendChild(tr);
                });
                
                table.appendChild(tbody);
                
                // IR headers row at the bottom
                const tfoot = document.createElement('tfoot');
                const footerRow = document.createElement('tr');
                footerRow.innerHTML = '<th></th>';
                matrix[0].forEach((note, index) => {
                    const th = document.createElement('th');
                    th.textContent = `IR${index}`;
                    th.setAttribute('data-type', 'IR');
                    th.setAttribute('data-index', index);
                    footerRow.appendChild(th);
                });
                footerRow.innerHTML += '<th></th>';
                tfoot.appendChild(footerRow);
                table.appendChild(tfoot);
            };

            // Function to render the grouped series
            const renderGroupedSeries = (series, groupSize) => {
                const container = document.getElementById('groupedSeriesContainer');
                if (!container) return;
                container.innerHTML = '';
                
                let groupNumber = 1;
                for (let i = 0; i < series.length; i += groupSize) {
                    const group = series.slice(i, i + groupSize);
                    
                    const groupDiv = document.createElement('div');
                    groupDiv.className = 'group-card';
                    const groupTitle = document.createElement('h4');
                    groupTitle.className = 'font-semibold text-gray-800 mb-2';
                    groupTitle.textContent = `Grupo ${groupNumber}`;
                    const groupList = document.createElement('ul');
                    groupList.className = 'group-display';
                    group.forEach(note => {
                        const li = document.createElement('li');
                        li.textContent = note;
                        li.className = 'note-item';
                        groupList.appendChild(li);
                    });
                    
                    groupDiv.appendChild(groupTitle);
                    groupDiv.appendChild(groupList);
                    container.appendChild(groupDiv);
                    groupNumber++;
                }
            };
            
            // Function to clear all note highlights
            const clearHighlights = (elementId) => {
                const ul = document.getElementById(elementId);
                if(ul) {
                    ul.querySelectorAll('.note-highlight').forEach(el => el.classList.remove('note-highlight'));
                }
            };
            
            // Function to stop Tone.js playback
            const stopAllPlayback = () => {
                if (sequence) {
                    Tone.Transport.stop();
                    sequence.stop();
                    sequence.dispose();
                    sequence = null;
                }
            };

            // Function to play a series using Tone.js and highlight notes
            const playSeries = (series, targetUlId) => {
                stopAllPlayback();
                if (Tone.context.state !== 'running') Tone.start();
                clearHighlights(targetUlId);
                
                if (!synth) {
                    const volume = new Tone.Volume(5).toDestination();
                    synth = new Tone.PolySynth(Tone.Synth, {
                        oscillator: { type: "sine" },
                        envelope: { attack: 0.005, decay: 0.1, sustain: 0.1, release: 1 },
                    }).connect(volume);
                }

                const notesWithOctave = series.slice(0, 12).map(note => note + '4');
                const noteElements = document.getElementById(targetUlId)?.querySelectorAll('.note-item');
                
                sequence = new Tone.Sequence((time, noteIndex) => {
                    if (noteIndex < notesWithOctave.length) {
                        const note = notesWithOctave[noteIndex];
                        synth.triggerAttackRelease(note, "8n", time);
                        
                        if (noteElements && noteIndex > 0) {
                            noteElements[noteIndex - 1].classList.remove('note-highlight');
                        }
                        if (noteElements) {
                            noteElements[noteIndex].classList.add('note-highlight');
                        }
                    }
                }, notesWithOctave.map((_, i) => i), "8n");

                sequence.loop = false;
                sequence.onstop = () => {
                    Tone.Transport.stop();
                    setTimeout(() => {
                       clearHighlights(targetUlId);
                    }, 500);
                };
                
                sequence.start(0);
                Tone.Transport.start();
            };

            // Function to get a series from the matrix
            const getSeriesFromMatrix = (matrix, type, index) => {
                if (!matrix || matrix.length === 0 || index === undefined || index < 0 || index >= matrix.length) {
                    console.error(`Error: Invalid matrix indices for type ${type} and index ${index}.`);
                    return [];
                }
                if (type === 'P') {
                    return matrix[index];
                } else if (type === 'I') {
                    return matrix.map(row => row[index]);
                } else if (type === 'R') {
                    return getRetrograde(matrix[index]);
                } else if (type === 'IR') {
                    return getRetrograde(matrix.map(row => row[index]));
                }
                return [];
            };

            // Function to handle the selection in the matrix (UPDATED)
            const handleMatrixClick = (event) => {
                clearMatrixHighlights();
                
                const element = event.target.closest('td, th');
                if (!element || !currentMatrix) return;
                
                let rowIndex, colIndex;
                const tagName = element.tagName;
                
                if (tagName === 'TD') {
                    // Clic en una celda
                    rowIndex = parseInt(element.dataset.row);
                    colIndex = parseInt(element.dataset.col);
                } else if (tagName === 'TH') {
                    // Clic en un encabezado
                    const type = element.dataset.type;
                    const index = parseInt(element.dataset.index);

                    if (type === 'P' || type === 'R') {
                        rowIndex = index;
                        colIndex = (type === 'P') ? 0 : 11;
                    } else if (type === 'I' || type === 'IR') {
                        rowIndex = (type === 'I') ? 0 : 11;
                        colIndex = index;
                    }
                } else {
                    return;
                }

                // Asegurar que los índices son válidos
                if (isNaN(rowIndex) || isNaN(colIndex)) return;
                
                // Resaltar la celda, fila y columna correspondiente
                const selectedCell = document.querySelector(`#matrixTable tbody tr:nth-child(${rowIndex + 1}) td:nth-child(${colIndex + 2})`);
                if (selectedCell) selectedCell.classList.add('matrix-cell-highlight');
                
                const selectedRow = document.querySelector(`#matrixTable tbody tr:nth-child(${rowIndex + 1})`);
                if (selectedRow) {
                    selectedRow.querySelectorAll('td').forEach(td => td.classList.add('matrix-cell-highlight'));
                    selectedRow.querySelector(`th[data-type="P"]`).classList.add('matrix-header-highlight');
                    selectedRow.querySelector(`th[data-type="R"]`).classList.add('matrix-header-highlight');
                }

                const selectedColHeaderI = document.querySelector(`#matrixTable thead tr th[data-type="I"][data-index="${colIndex}"]`);
                if (selectedColHeaderI) selectedColHeaderI.classList.add('matrix-header-highlight');

                const selectedColHeaderIR = document.querySelector(`#matrixTable tfoot tr th[data-type="IR"][data-index="${colIndex}"]`);
                if (selectedColHeaderIR) selectedColHeaderIR.classList.add('matrix-header-highlight');

                document.querySelectorAll(`#matrixTable tbody tr`).forEach(row => {
                    const colCell = row.querySelector(`td:nth-child(${colIndex + 2})`);
                    if (colCell) colCell.classList.add('matrix-cell-highlight');
                });

                // Obtener las series a partir de la matriz para la celda o encabezado clicado
                selectedMatrixSeries = {
                    P: getSeriesFromMatrix(currentMatrix, 'P', rowIndex),
                    I: getSeriesFromMatrix(currentMatrix, 'I', colIndex),
                    R: getSeriesFromMatrix(currentMatrix, 'R', rowIndex),
                    IR: getSeriesFromMatrix(currentMatrix, 'IR', colIndex)
                };

                // Establecer títulos dinámicos
                document.getElementById('seriesTitleP').textContent = `Prime (P${rowIndex}):`;
                document.getElementById('seriesTitleI').textContent = `Inversión (I${colIndex}):`;
                document.getElementById('seriesTitleR').textContent = `Retrógrada (R${rowIndex}):`;
                document.getElementById('seriesTitleIR').textContent = `Inversión Retrógrada (IR${colIndex}):`;

                // Renderizar las series en el panel
                renderSeries('selectedSeriesNotesP', selectedMatrixSeries.P);
                renderSeries('selectedSeriesNotesI', selectedMatrixSeries.I);
                renderSeries('selectedSeriesNotesR', selectedMatrixSeries.R);
                renderSeries('selectedSeriesNotesIR', selectedMatrixSeries.IR);
                
                // Mostrar el panel de series seleccionadas
                document.getElementById('matrixSeriesDisplay').classList.remove('hidden');
            };
            
            // Function to clear all matrix highlights
            const clearMatrixHighlights = () => {
                document.querySelectorAll('.matrix-cell-highlight').forEach(cell => cell.classList.remove('matrix-cell-highlight'));
                document.querySelectorAll('.matrix-header-highlight').forEach(header => header.classList.remove('matrix-header-highlight'));
            };

            // Main function to generate and render everything.
            const generateAndRenderAll = () => {
                stopAllPlayback();
                const primeSeries = generateRandomSeries();
                const inversionSeries = getInversion(primeSeries);
                const retrogradeSeries = getRetrograde(primeSeries);
                const inversionRetrogradeSeries = getInversionRetrograde(primeSeries);

                currentSeriesData = {
                    prime: primeSeries,
                    inversion: inversionSeries,
                    retrograde: retrogradeSeries,
                    inversionRetrograde: inversionRetrogradeSeries,
                };
                
                currentMatrix = generateMatrix(primeSeries);

                renderSeries('primeSeries', primeSeries);
                renderSeries('inversionSeries', inversionSeries);
                renderSeries('retrogradeSeries', retrogradeSeries);
                renderSeries('inversionRetrogradeSeries', inversionRetrogradeSeries);
                renderMatrix(currentMatrix);
                
                const groupSelect = document.getElementById('groupSelect');
                renderGroupedSeries(primeSeries, parseInt(groupSelect.value));
                
                document.getElementById('matrixSeriesDisplay').classList.add('hidden');
            };

            // Function to save the interface as an image
            const saveAsImage = () => {
                const appCard = document.getElementById('appCard');
                html2canvas(appCard, {
                    scale: 2,
                    useCORS: true
                }).then(canvas => {
                    const link = document.createElement('a');
                    link.download = 'serie-dodecafonica.png';
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                });
            };

            // Event listener for all play buttons using event delegation
            document.getElementById('appCard').addEventListener('click', (event) => {
                const button = event.target.closest('button.play-button');
                if (!button) return;

                const seriesType = button.dataset.seriesType;
                const targetUlId = button.dataset.targetId;
                let seriesToPlay;

                if (targetUlId.startsWith('selected')) {
                    if (selectedMatrixSeries && selectedMatrixSeries[seriesType]) {
                        seriesToPlay = selectedMatrixSeries[seriesType];
                    }
                } else if (currentSeriesData && currentSeriesData[seriesType]) {
                    seriesToPlay = currentSeriesData[seriesType];
                }

                if (seriesToPlay) {
                    playSeries(seriesToPlay, targetUlId);
                } else {
                    console.error('Series not found for type:', seriesType);
                }
            });


            document.getElementById('generateButton').addEventListener('click', generateAndRenderAll);
            document.getElementById('saveButton').addEventListener('click', saveAsImage);
            
            const groupSelect = document.getElementById('groupSelect');
            groupSelect.addEventListener('change', (event) => {
                const newGroupSize = parseInt(event.target.value);
                if (currentSeriesData && currentSeriesData.prime) {
                    renderGroupedSeries(currentSeriesData.prime, newGroupSize);
                }
            });

            // Listener for matrix clicks
            document.getElementById('matrixTable').addEventListener('click', handleMatrixClick);
            
            // Initial rendering.
            generateAndRenderAll();
        });
    </script>
</body>
</html>

